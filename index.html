<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Arvisha's Catch Game</title>
  <style>
    body {
      margin: 0;
      background: #87CEEB;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: #fff;
    }
    #game-over {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      background: rgba(255,255,255,0.8);
      padding: 20px;
      border-radius: 10px;
      display: none;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="720" height="1280"></canvas>
<div id="game-over">Game Over! Refresh to Play Again</div>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const playerImg = new Image();
  playerImg.src = "arvisha.png";

  // Load 17 relatives
const relativeImages = [];
for (let i = 1; i <= 17; i++) {
  const img = new Image();
  img.src = `relative${i}.png`; // Make sure you have relative1.png to relative17.png in the folder
  relativeImages.push(img);
}

  const catchSound = new Audio("catch.mp3");
  const missSound = new Audio("miss.mp3");

  const player = {
    x: canvas.width / 2 - 65,
    y: canvas.height - 180,
    width: 130,
    height: 160,
    speed: 8,
    dx: 0
  };

  let relatives = [];
  let score = 0;
  let lives = 3;

 function createRelative() {
  const minHorizontalDistance = 400;
  const minVerticalDistance = 600;

  // Soft limit: only spawn if fewer than 4 relatives currently on screen
  if (relatives.length >= 4) return;

  const newX = Math.random() * (canvas.width - 90);

  for (let r of relatives) {
    const horizontalDistance = Math.abs(r.x - newX);
    const verticalDistance = Math.abs(r.y - (-90));

    if (horizontalDistance < minHorizontalDistance && verticalDistance < minVerticalDistance) {
      // Too close to an existing relative — don’t spawn this frame
      return;
    }
  }

  relatives.push({
    x: newX,
    y: -90,
    width: 90,
    height: 90,
    speed: 3 + Math.random() * 0.5,
    image: relativeImages[Math.floor(Math.random() * relativeImages.length)]
  });
}

function update() {
  player.x += player.dx;
  player.x = Math.max(0, Math.min(canvas.width - player.width, player.x));

  for (let i = 0; i < relatives.length; i++) {
    let r = relatives[i];
    r.y += r.speed;

    if (
      r.x < player.x + player.width &&
      r.x + r.width > player.x &&
      r.y < player.y + player.height &&
      r.y + r.height > player.y
    ) {
      catchSound.play();
      score++;
      relatives.splice(i, 1);
      i--;
    } else if (r.y > canvas.height) {
      missSound.play();
      lives--;
      relatives.splice(i, 1);
      i--;
    }
  }

  if (lives <= 0) {
    document.getElementById("game-over").style.display = "block";
    return;
  }

  // Only create if less than 6 on screen
  if (Math.random() < 0.02 && relatives.length < 6) {
    createRelative();
  }

  draw();
  requestAnimationFrame(update);
}

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);

    for (let r of relatives) {
      ctx.drawImage(r.image, r.x, r.y, r.width, r.height);
    }

    ctx.fillStyle = "black";
    ctx.font = "24px Arial";
    ctx.fillText("Score: " + score, 10, 30);
    ctx.fillText("Lives: " + lives, 10, 60);
  }

  // Smooth movement controls
  window.addEventListener("keydown", function(e) {
    if (e.key === "ArrowLeft") {
      player.dx = -player.speed;
    } else if (e.key === "ArrowRight") {
      player.dx = player.speed;
    }
  });

  window.addEventListener("keyup", function(e) {
    if (e.key === "ArrowLeft" || e.key === "ArrowRight") {
      player.dx = 0;
    }
  });

  // Start game
  update();
</script>
</body>
</html>